""" Utility functions used in writing files"""

import filecmp
import logging
import tempfile

from pathlib import Path

import pandas as pd

logger = logging.getLogger(__name__)


def make_dir_for(file_path: Path) -> None:
    """makes directories for file_path if they don't already exist"""
    directory = file_path.parent
    if directory != Path("."):
        directory.mkdir(parents=True, exist_ok=True)


def check_existing_file(file_path: Path, overwrite: bool = False) -> None:
    """Creates directories as needed and throws an error if file exists and overwrite is False"""
    make_dir_for(file_path)
    try:
        if not overwrite and file_path.exists():
            raise FileExistsError(f"Not overwriting {file_path}.")
    except FileExistsError as err:
        logger.exception(err)
        raise


def export_dataframe(dataframe, file_path, description, overwrite=False, **kwargs):
    """
    inputs:
        dataframe: pandas DataFrame to save
        file_path: string with path of file to create
        description: free string for logging
        overwrite: if False, raise error if file already exists
        remaining arguments are passed through to to_csv()
    """
    check_existing_file(file_path, overwrite)
    dataframe.to_csv(file_path, **kwargs)
    logger.info("Exported %s to %s.", description, file_path)


def raise_on_diff(dataframe: pd.DataFrame, file_path: Path, description: str, **kwargs) -> None:
    """
    inputs:
        dataframe: data to save
        file_path: path of file to compare against
        description: free string for logging
        kwargs: passed through to to_csv()

    If file_path exists and does not match file that would be generated by
    saving dataframe to a csv, then raise ValueError
    """
    if not file_path.exists():
        return
    with tempfile.NamedTemporaryFile(delete=False) as temp_path:
        dataframe.to_csv(temp_path, **kwargs)
        same = filecmp.cmp(file_path, temp_path.name, shallow=False)
        Path(temp_path.name).unlink()
    if same:
        logger.info("Data in %s is the same as %s.", description, file_path)
    else:
        try:
            raise ValueError(f"Data in {description} is not the same as {file_path}.")
        except ValueError as err:
            logger.exception(err)
            raise


def export_dataframe_die_on_diff(dataframe, file_path, description, overwrite=False, **kwargs):
    """
    inputs:
        dataframe: pandas DataFrame to save
        file_path: string with path of file to create
        description: free string for logging
        overwrite: bool
        kwargs: passed through to to_csv()

    If overwrite then save the dataframe to file_path
    If file_path does not exist then save the dataframe there
    If file_path exists and matches data in dataframe then do nothing
    If file_path exists and does not match dataframe then raise ValueError
    """
    if overwrite:
        export_dataframe(dataframe, file_path, description, overwrite, **kwargs)
    else:
        raise_on_diff(dataframe, file_path, description, **kwargs)
        if not file_path.exists():
            export_dataframe(dataframe, file_path, description, **kwargs)


def output_dir(
    base: Path,
    experiment: str,
    workflow: str,
    analysis: str,
    rt_num: int,
    analysis_num: int,
    username: str,
    draft: bool,
    additional: bool = False,
) -> Path:
    """Creates the output directory and returns the path as a string"""
    sub_dirs = [
        experiment,
        f"{username}_{workflow}_{rt_num}_{analysis_num}",
        "Targeted",
        f"{workflow}_{experiment}",
        f"{analysis}{'_draft' if draft else ''}",
    ] + (["Additional_info"] if additional else [])
    out = base.joinpath(*sub_dirs)
    out.mkdir(parents=True, exist_ok=True)
    return out
